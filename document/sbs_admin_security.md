<a href="../README.md">README</a>

# Redis Security

本章将站在Redis的观点上对安全问题的各个方面进行讲解:Redis提供的访问控制，代码安全性问题，可以通过选择恶意输入和其他类似主题从外部触发的攻击。

## Redis general security model

Redis旨在由受信任环境中的受信任客户端访问。这意味着通常不会将Redis实例直接暴露给Internet，或者通常是不受信任的客户端可以直接访问Redis TCP端口或UNIX套接字的环境。  
例如，在使用Redis作为数据库，缓存或消息传递系统实现的Web应用程序的公共上下文中，应用程序前端（Web端）内的客户端将查询Redis以生成页面或执行请求的操作或 由Web应用程序用户触发。   
在这种情况下，Web应用程序调解Redis和不受信任的客户端（访问Web应用程序的用户浏览器）之间的访问。   
这是一个具体示例，但是，通常，对Redis的不受信任访问应始终由实现ACL的层，验证用户输入以及决定对Redis实例执行哪些操作来调解。

一般而言，Redis未针对最大安全性进行优化，而是为了获得最佳性能和简单性。

## Network security

除了网络中受信任的客户端之外，应该拒绝访问Redis端口，因此运行Redis的服务器只能由使用Redis实现应用程序的计算机直接访问。  
在直接暴露于互联网的单台计算机的常见情况下，例如虚拟化的Linux实例（Linode，EC2，...），Redis端口应防火墙以防止从外部访问。 客户端仍然可以使用环回接口访问Redis。  
请注意，可以通过在redis.conf文件中添加如下行来将Redis绑定到单个网络：

```bash
bind 127.0.0.1
```

由于Redis的性质，未能从外部保护Redis端口可能会产生很大的安全影响。 例如，外部攻击者可以使用单个FLUSHALL命令删除整个数据集。

## Protected mode

遗憾的是，许多用户无法保护Redis实例不被外部网络访问。许多实例只是在公共IP上暴露在互联网上。正是因为这样，从Redis版本3.2.0开始，当redis没有设置密码和可访问网络，那么redis将会运行在保护模式。在此模式下，Redis仅回复来自环回接口的查询，并回复与其他地址连接的其他客户端的错误，解释正在发生的事情以及如何正确配置Redis。  
我们希望保护模式能够大量降低因未经正确管理而执行的未受保护的Redis实例导致的安全问题，但系统管理员仍然可以忽略Redis提供的错误，只需禁用保护模式或手动绑定所有接口。

## Authentication feature

虽然Redis没有尝试实现访问控制，但它提供了一个很小的身份验证层，可选择打开编辑redis.conf文件。  
启用授权层后，Redis将拒绝未经身份验证的客户端的任何查询。 客户端可以通过发送AUTH命令后跟密码来验证自身。  
密码由系统管理员以明文形式在redis.conf文件中设置。 它应该足够长以防止暴力攻击有两个原因：

* Redis在提供查询方面非常快。 每秒许多密码可以由外部客户端测试。
* Redis密码存储在redis.conf文件内部和客户端配置中，因此不需要系统管理员记住，因此可能会很长。  

认证层的目标是可选地提供冗余层。 如果防火墙或任何其他用于保护Redis免受外部攻击者攻击的系统失败，则外部客户端仍然无法在不知道身份验证密码的情况下访问Redis实例。

与其他所有Redis命令一样，AUTH命令是未加密的，因此它不能防止有足够访问权限的攻击者进行窃听。

## Data encryption support

Redis不支持加密。 为了实现可信方可以通过Internet或其他不受信任的网络访问Redis实例的设置，应该实施额外的保护层，例如SSL代理。 我们建议使用spiped。

## Disabling of specific commands

可以在Redis中禁用命令或将它们重命名为不可授权的名称，以便普通客户端仅限于指定的命令集。  
例如，虚拟化服务器提供商可以提供托管的Redis实例服务。 在此上下文中，普通用户可能无法调用Redis CONFIG命令来更改实例的配置，但提供和删除实例的系统应该能够这样做。   
在这种情况下，可以从命令表重命名或完全隐藏命令。 此功能作为可在redis.conf配置文件中使用的语句提供。 例如：

```bash
rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
```
在上面的示例中，CONFIG命令已重命名为不可授权的名称。 也可以通过将其重命名为空字符串来完全禁用它（或任何其他命令），如下例所示：

```bash
rename-command CONFIG ""
```

## Attacks triggered by carefully selected inputs from external clients

即使没有外部访问实例，攻击者也可以从外部触发一类攻击。 这种攻击的一个例子是能够将数据插入Redis，从而触发Redis内部实现的数据结构的病态（最坏情况）算法复杂性。

例如，攻击者可以通过Web表单提供一组字符串，这些字符串已知为同一个桶散列到哈希表中，以便将O（1）预期时间（平均时间）转换为O（N ）最糟糕的情况是，消耗的CPU比预期的多，最终导致拒绝服务。

为防止此特定攻击，Redis对散列函数使用预处理执行伪随机种子。

Redis使用qsort算法实现SORT命令。 目前，该算法不是随机的，因此可以通过仔细选择正确的输入集来触发二次最坏情况行为。

## String escaping and NoSQL injection

Redis协议没有字符串转义的概念，因此在正常情况下使用普通客户端库无法进行注入。 该协议使用前缀长度字符串，完全是二进制安全的。

由EVAL和EVALSHA命令执行的Lua脚本遵循相同的规则，因此这些命令也是安全的。

虽然这是一个非常奇怪的用例，但应用程序应该避免使用从不受信任的源获取的字符串来组成Lua脚本的主体。

## Code security

在传统的Redis设置中，允许客户端完全访问命令集，但是访问实例永远不会导致控制Redis运行的系统的能力。  
在内部，Redis使用所有众所周知的实践来编写安全代码，防止缓冲区溢出，格式化错误和其他内存损坏问题。 但是，使用CONFIG命令控制服务器配置的能力使客户端能够更改程序的工作目录和转储文件的名称。 这允许客户端在随机路径上编写RDB Redis文件，这是一个安全问题，可能很容易导致破坏系统和/或运行不受信任的代码，因为Redis正在运行相同的用户。  
Redis不需要root权限即可运行。 建议将其作为无特权的redis用户运行，仅用于此目的。 Redis作者目前正在研究添加新配置参数以防止CONFIG SET / GET目录和其他类似运行时配置指令的可能性。 这将阻止客户端强制服务器在任意位置写入Redis转储文件。  